#!/bin/bash
#
# - yuriy.ilnytsky@datarobot.com
#
#### #### #### #### #### #### #### ####
#
# Run it without parameters to get help
#
# Put backups in the dr8-backup subdirectory
# or create synlink dr8-backup pointing to the directory with DataRobot 8 backups
#
BACKUPS_DIR="./dr8-backup"

#### #### #### #### #### #### #### ####
ERROR () {
        echo
        echo "# ERROR."
        echo "$@"
        echo
        exit 1
}

#### #### #### #### #### #### #### ####
backup_check () {
  if [ -d "${RESTORE_DIR}" ] || [ -L "${RESTORE_DIR}" ]; then
    echo ".-- ${RESTORE_DIR} found"
  else
    ERROR "DataRobot 8 backup not found.
In the current directory you should have ${BACKUPS_DIR} created,
it should be one of two:
  - the directory containing the backup
or
  - symlink to directory containing the backup
"
  fi
  [ -d "${RESTORE_DIR}" ] || ERROR "Directory with DataRobot 8 backups not found (${RESTORE_DIR})"
  echo "|-- DataRobot 8 backups directory: ${RESTORE_DIR}"
  for i in ${SECRETS_RESTORE_DIR} ${MONGO_RESTORE_DIR} ${PGSQL_RESTORE_DIR}; do
    [ -d "$i" ] && echo "|   |-- DataRobot 8 backup directory $i" || ERROR "Directory not found: $i"
  done
  [ -f ${KEY1_FILE} ] || ERROR "File ${KEY1_FILE} not found"
  [ -f ${KEY2_FILE} ] || ERROR "File ${KEY2_FILE} not found"
  [ -z "${ASYMMETRIC_KEY_PAIR_MONGO_ENCRYPTION_KEY}" ] && echo "Received empty ASYMMETRIC_KEY_PAIR_MONGO_ENCRYPTION_KEY from ${KEY1_FILE}"
  [ -z "${DRSECURE_MONGO_ENCRYPTION_KEY}" ] && echo "Received empty DRSECURE_MONGO_ENCRYPTION_KEY from ${KEY2_FILE}"
  [ -z "${MONGO_RESTORE_TAR}" ] && ERROR "Mongo restore tar ${MONGO_RESTORE_DIR}/datarobot-mongo50-backup-*.tar not found"
  [ -f "${MONGO_RESTORE_TAR}" ] || ERROR "Mongo restore tar ${MONGO_RESTORE_TAR} does not exist"
  [ -z "${PGSQL_RESTORE_TAR}" ] && ERROR "PgSQL restore tar ${PGSQL_RESTORE_DIR}/pgsql-modmon-*.tar not found"
  [ -f "${PGSQL_RESTORE_TAR}" ] || ERROR "PgSQL restore tar ${PGSQL_RESTORE_TAR} does not exist"
  echo "|-- DataRobot 8 Backup files:"
  echo "|   |-- ${KEY1_FILE}"
  echo "|   |-- ${KEY2_FILE}"
  echo "|   |-- ${MONGO_RESTORE_TAR}"
  echo "|   '-- ${PGSQL_RESTORE_TAR}"
  [ -f ${PRIME} ] || ERROR "file ${PRIME} not found"
  echo "|-- ${PRIME} found"
}

#### #### #### #### #### #### #### ####
version_check () {
  [ -z "${DR_CURRENT_VERSION}" ] && ERROR "Current DataRobot version not found"
  echo "|-- DataRobot version: ${DR_CURRENT_VERSION}"
  echo "${DR_CURRENT_VERSION}"|grep '^11\.' >/dev/null || ERROR "only DataRobot 11 is supported"
  [ -z "${DR_CORE_NAMESPACE}" ] && ERROR "DataRobot namespace not found"
  echo "|   |-- DR_CORE_NAMESPACE: ${DR_CORE_NAMESPACE}"
  [ -z "${DR_RELEASE}" ] && ERROR "DataRobot helm release name not found"
  echo "|   '-- DataRobot release: ${DR_RELEASE}"
}

#### #### #### #### #### #### #### ####
get_config () {
  echo "|-- Configs:"
  echo "|   |-- DataRobot helm chart values"
  helm -n ${DR_CORE_NAMESPACE} get values ${DR_RELEASE} > ${VALUES} || \
    ERROR "Error getting values: helm -n ${DR_CORE_NAMESPACE} get values ${DR_RELEASE}"
  echo "|   |   |-- values.yaml retrieved"
  if grep '^\s*MMM_SKIP_BIGINT_MIGRATION:\s' ${VALUES} >/dev/null; then
    echo "|   |   |-- MMM_SKIP_BIGINT_MIGRATION variable found"
  else
    sed -i "0,/^\s\sconfig_env_vars:/ {s/^\(\s\sconfig_env_vars:\)/\1\n    MMM_SKIP_BIGINT_MIGRATION: true/}" ${VALUES}
    echo "|   |   '-- MMM_SKIP_BIGINT_MIGRATION variable added"
  fi
  echo "|   |-- core-credentials secret values"
  kubectl -n ${DR_CORE_NAMESPACE} get secrets core-credentials -o yaml > core-credentials-org.yaml || ERROR "failed action: kubectl -n ${DR_CORE_NAMESPACE}     get secrets core-credentials -o yaml"
  echo "|   |   |-- core-credentials-org.yaml retrieved"
  local ASYMM=$(echo -n "${ASYMMETRIC_KEY_PAIR_MONGO_ENCRYPTION_KEY}"|base64 -w0)
  local DRSEC=$(echo -n "${DRSECURE_MONGO_ENCRYPTION_KEY}"|base64 -w0)
  cat core-credentials-org.yaml|sed -e ':a' -e '/|[[:space:]]*$/N;s/|\n[[:space:]]*/| /;ta' |grep -vE 'kubectl.kubernetes.io/last-applied-configuration:|creationTimestamp:|resourceVersion:|uid:'|sed "s/^\(\s*asymmetrickey:\).*$/\1 ${ASYMM}/g;s/^\(\s*drsecurekey:\).*$/\1 ${DRSEC}/g;" > core-credentials.yaml
  #cat core-credentials-org.yaml|sed "s/^\(\s*asymmetrickey:\).*$/\1 ${ASYMM}/g;s/^\(\s*drsecurekey:\).*$/\1 ${DRSEC}/g;" > core-credentials.yaml
  echo "|   |   '-- new core-credentials.yaml generated"
  echo "|   '-- core-credentials secret values"
  DOMAIN=$(grep '^\s*domain:' values.yaml |awk '{print $2}')
  echo "|"
  echo "|-- DataRobot domain: ${DOMAIN}"
  echo "|"
}

#### #### #### #### #### #### #### ####
check_config () {
  cat ${VALUES}|grep "^\s*MMM_SKIP_BIGINT_MIGRATION:" >/dev/null && \
    echo "|-- MMM_SKIP_BIGINT_MIGRATION found" || \
    ERROR "variable MMM_SKIP_BIGINT_MIGRATION not found in ${VALUES}, it should be added before the restoration"
}

#### #### #### #### #### #### #### ####
scale_down () {
        #
        # Scale down
        #
  echo "|-- DataRobot scaling down"
        echo "|-- Annotate number of replicas:"
        for i in $(kubectl -n ${DR_CORE_NAMESPACE} get deploy -o name -l release=${DR_RELEASE}) deployment.apps/pcs-pgpool; do
                local REPLICAS=$(kubectl -n ${DR_CORE_NAMESPACE} get ${i} -o jsonpath='{.spec.replicas}' 2>&1)
                [ -z "${REPLICAS}" ] && ERROR "Empty number of replicas received for ${i}"
                if [ "x${REPLICAS}" == "x0" ]; then
                        echo "|   |-- 0 replicas received for $i, no need to annotate"
                else
                        OUT=$(kubectl -n ${DR_CORE_NAMESPACE} annotate --overwrite ${i} replicas=${REPLICAS} 2>&1)
                        echo "|   |-- $i replicas ${REPLICAS} annotated"
                fi
        done
        echo "|   '-- Annotate number of replicas: Ok"
        echo "|-- Scale down namespace ${DR_CORE_NAMESPACE} helm release ${DR_RELEASE} ..."
        kubectl -n ${DR_CORE_NAMESPACE} scale deploy -l release=${DR_RELEASE} --replicas=0 2>&1 |sed 's/^/|   |-- /g'
        kubectl -n ${DR_CORE_NAMESPACE} scale deploy pcs-pgpool --replicas=0 2>&1 |sed 's/^/|   |-- /g'
        echo "|   '-- Scale down namespace ${DR_CORE_NAMESPACE} helm release ${DR_RELEASE}: Ok"
  echo "|-- DataRobot scaling down"
}
#### #### #### #### #### #### #### ####
scale_show () {
  for i in $(kubectl -n ${DR_CORE_NAMESPACE} get deploy -o name -l release=${DR_RELEASE}) deployment.apps/pcs-pgpool; do echo "$i $(kubectl -n ${DR_CORE_NAMESPACE} get ${i} -o jsonpath='{.spec.replicas}')"; done
}

#### #### #### #### #### #### #### ####
#### #### #### #### #### #### #### ####
scale_up () {
        #
        # scale up
        #
  echo ".-- DataRobot scaling up"
        echo "|-- Scaling up (restoring number of replicas):"
        for i in deployment.apps/pcs-pgpool $(kubectl -n ${DR_CORE_NAMESPACE} get deploy -o name -l release=${DR_RELEASE}); do
                local REPLICAS_CURRENT=$(kubectl -n ${DR_CORE_NAMESPACE} get ${i} -o jsonpath='{.spec.replicas}' 2>&1)
                [ -z "${REPLICAS_CURRENT}" ] && ERROR "Empty number of replicas received for ${i}"
                local REPLICAS=$(kubectl -n $DR_CORE_NAMESPACE get ${i} -o jsonpath='{.metadata.annotations.replicas}' 2>&1)
                [ -z "${REPLICAS}" ] && ERROR "Empty number of replicas received for ${i}"
                kubectl -n $DR_CORE_NAMESPACE scale ${i} --replicas=${REPLICAS} >/dev/null
                #kubectl -n $DR_CORE_NAMESPACE annotate ${i} replicas- >/dev/null
                echo "|   |-- replicas ${REPLICAS_CURRENT} -> ${REPLICAS} for ${i}"
        done
        echo "|   '-- Scaling up: Ok"
  echo "'-- DataRobot scaling up"
        return 0
}

#### #### #### #### #### #### #### ####
disable_cron_job () {
  kubectl -n ${DR_CORE_NAMESPACE} patch cronjob core-integration-tasks-mongo-migration-job -p '{"spec":{"suspend":true}}'|sed 's/^/|-- Disabling: /g'
  #echo "|-- cron job core-integration-tasks-mongo-migration-job disabled"
  #kubectl get cronjobs -n $NS | grep mongo
}

#### #### #### #### #### #### #### ####
enable_cron_job () {
  kubectl -n ${DR_CORE_NAMESPACE} patch cronjob core-integration-tasks-mongo-migration-job -p '{"spec":{"suspend":false}}'|sed 's/^/|-- Enabling: /g'
  #echo "|-- cron job core-integration-tasks-mongo-migration-job enabled"
  #kubectl get cronjobs -n $NS | grep mongo
}

#### #### #### #### #### #### #### ####
core_credentials () {
  kubectl -n ${DR_CORE_NAMESPACE} apply -f core-credentials.yaml >/dev/null || ERROR "Failed action: kubectl -n ${DR_CORE_NAMESPACE} apply -f core-credentials.yaml"
  echo "|-- core-credentials secret reconfigured"
}

#### #### #### #### #### #### #### ####
restore_mongo_local () {
  [ ! -f "${MONGO_RESTORE_TAR}" ] && ERROR "Cannot find MongoDB backup: ${MONGO_RESTORE_TAR}"
  local FNAMEPATH=$(realpath ${MONGO_RESTORE_TAR})
  [ -f ${FNAMEPATH} ] || ERROR "MongoDB backup tar ${FNAMEPATH} not found"
  local FNAME="mongo.tar"
  echo "|-- MongoDB backup: ${FNAMEPATH}"
  echo "|   '-- backup size: $(ls -lah ${FNAMEPATH}|awk '{print $5}')"
  echo -n "|-- Copying inside of pod pcs-mongo-0 ... "
  kubectl -n ${DR_CORE_NAMESPACE} cp ${FNAMEPATH} pcs-mongo-0:/tmp/${FNAME} || ERROR "cannot copy file inside of container"
  echo Ok
  #kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-mongo-0 -- ls -la /tmp/${FNAME} || ERROR "cannot ls the result file inside of container"
  echo -n "|-- Extracting backup from archive inside of the pod ... "
  kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-mongo-0 -- bash -c "cd /tmp && tar xf ${FNAME}" || ERROR "cannot untar the file inside of container"
  echo Ok
  echo "|-- Backup content:"
  kubectl -n ${DR_CORE_NAMESPACE} exec pcs-mongo-0 -it -- bash -c "du -sh /tmp/backup/*|sed 's/^/|   |-- /g'"
  echo "|   '-- Backup content"
  # TEST
  echo "|-- Test to retrieve MongoDB data, list of users:"
  (echo -e "use MMApp\ndb.users.find({activated:1},{username:true})\n")|kubectl -n ${DR_CORE_NAMESPACE} exec pcs-mongo-0 -i -- bash -c 'mongosh -u ${MONGODB_ROOT_USER} -p ${MONGODB_ROOT_PASSWORD}'|grep username|sed 's/^/|   |- /g'
  echo "|   '-- Test"
  # DELETE DATABASES
  echo "|-- List of MongoDB databases:"
  echo -e "show databases"|kubectl -n ${DR_CORE_NAMESPACE} exec pcs-mongo-0 -i -- bash -c 'mongosh -u ${MONGODB_ROOT_USER} -p ${MONGODB_ROOT_PASSWORD}' |awk 'BEGIN{PRINT=0}{if(/^rs0 /){if(PRINT){PRINT=0}else{PRINT=1}};if(PRINT){print}}'|sed 's/^.*> //g; s/^/|   |-- /g'
  echo "|   '-- List"
  echo -n "|-- Are you sure you want to drop and restore MongoDB databases? (y/N): "
  read i
  ANSWER=$(echo "${i}"|xargs|tr 'A-Z' 'a-z')
  if [ "x${ANSWER}" != "xy" ]; then
    echo "|   '-- Restoration not confirmed"
    echo "|"
  else
    echo "|-- Processing with MongoDB restoration"
    echo "|-- Dropping databases: MMApp application_builder audit datasetsi usersecrets"
    for i in MMApp application_builder audit datasets usersecrets; do
      echo -e "use $i\ndb.dropDatabase()\n"|kubectl -n $DR_CORE_NAMESPACE exec pcs-mongo-0 -i -- bash -c 'mongosh -u ${MONGODB_ROOT_USER} -p ${MONGODB_ROOT_PASSWORD}' >/dev/null
    done
    echo "|-- List of MongoDB databases:"
    echo -e "show databases"|kubectl -n ${DR_CORE_NAMESPACE} exec pcs-mongo-0 -i -- bash -c 'mongosh -u ${MONGODB_ROOT_USER} -p ${MONGODB_ROOT_PASSWORD}' |awk 'BEGIN{PRINT=0}{if(/^rs0 /){if(PRINT){PRINT=0}else{PRINT=1}};if(PRINT){print}}'|sed 's/^.*> //g; s/^/|   |-- /g'
    echo "|   '-- List"
    echo "|-- Ready to restore DataBase"
    echo
    echo "Press ENTER to continue or Ctrl-C to stop"
    echo
    read i
    # RESTORE
    echo "|-- Reastoring MongoDB, depending on size, it may take long..."
    echo "    you can check logs in mongo_restore.log"
    #kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-mongo-0 -- bash -c 'mongorestore -u pcs-mongodb -p ${MONGODB_ROOT_PASSWORD} -h localhost /tmp/backup 2>&1|tee /tmp/mongo_restore.log'
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-mongo-0 -- bash -c 'mongorestore -u pcs-mongodb -p ${MONGODB_ROOT_PASSWORD} -h localhost -j 4 /tmp/backup 2>&1' 2>&1 > mongo_restore.log
    if [ $? -eq 0 ]; then
      echo
      echo "|   |-- MongoDB restoration exit code is 0, congrats!"
    else
      echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
      echo "WARNING: MongoDB restoration exit code is not 0, check log mongo_restore.log"
      echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    fi
    #kubectl -n ${DR_CORE_NAMESPACE} cp pcs-mongo-0:/tmp/mongo_restore.log ./mongo_restore.log >/dev/null || echo "!!!! Cannot copy pcs-mongo-0:/tmp/mongo_restore.log"
    echo "|   '-- MongoDB restoration log: mongo_restore.log"
    echo "|-- Completed: mongodb database restoration finished"
  fi
}

#### #### #### #### #### #### #### ####
restart_mongodb () {
    local REPLICAS=$(kubectl -n ${DR_CORE_NAMESPACE} get sts pcs-mongo -o jsonpath='{.status.replicas}')
    echo "|-- Number of replicas of statefulset pcs-mongodb: ${REPLICAS}"
    echo -n "|-- Restarting statefulset pcs-mongodb ... "
    kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-mongo --replicas=0 >/dev/null
    while kubectl -n ${DR_CORE_NAMESPACE} get po|grep pcs-mongo- >/dev/null; do sleep 10; done
    kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-mongo --replicas=${REPLICAS} >/dev/null
    while ! kubectl -n ${DR_CORE_NAMESPACE} get po|grep 'pcs-mongo-.\s*1/1' >/dev/null; do sleep 10; done
    echo Ok
}

#### #### #### #### #### #### #### ####
fix_value () {
  local F=$1
  local A=$2
  local B=$3
  local T=${F}.tmp
  awk "BEGIN{fix=0}{if(/public.${A} \(/){fix=1};if(fix == 1){if(/^\s*${B} integer/){"'sub(" integer"," bigint",$0)'";fix=0}};print;}" ${F}> ${T} && mv -f ${T} ${F}
  echo "|   |   |-- Table ${A}.${B}: integer -> bigint"
}

#### #### #### #### #### #### #### ####
restore_pgsql_local () {
  [ ! -f "${PGSQL_RESTORE_TAR}" ] && ERROR "Cannot find PGSQL backup: ${PGSQL_RESTORE_TAR}"
  kubectl -n ${DR_CORE_NAMESPACE} scale deployment pcs-pgpool --replicas=0 >/dev/null
  echo "|-- Confirming deployment pcs-pgpool is scaled down to 0 replicas"
  local FNAMEPATH=$(realpath ${PGSQL_RESTORE_TAR})
  [ -f ${FNAMEPATH} ] || ERROR "PostgreSQL backup tar ${FNAMEPATH} not found"
  local FNAME="pgsql-modmon.tar"
  echo "|-- PostgreSQL backup: ${FNAMEPATH}"
  echo "|   '-- backup size: $(ls -lah ${FNAMEPATH}|awk '{print $5}')"
  echo -n "|-- Copying inside of pod pcs-postgresql-0 ... "
	#export PGPASSWORD=$(kubectl -n $DR_CORE_NAMESPACE get secret pcs-postgresql -o jsonpath='{.data.postgres-password}' | base64 -d)
	#[ -z "${PGPASSWORD}" ] && ERROR "Cannot retrieve PGSQL password"
  kubectl -n ${DR_CORE_NAMESPACE} cp ${FNAMEPATH} pcs-postgresql-0:/tmp/${FNAME} || ERROR "cannot copy file inside of container"
  echo Ok

  echo -n "|-- Extracting backup from archive inside of the pod ... "
  kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c "cd /tmp && tar xf ${FNAME}" || ERROR "cannot untar the file inside of container"
  echo Ok

  echo "|-- Backup content:"
  kubectl -n ${DR_CORE_NAMESPACE} exec pcs-postgresql-0 -it -- bash -c "du -sh /tmp/backup/*|sed 's/^/|   |-- /g'"
  echo "|   '-- Backup content"

  echo "|-- Preparing Postgresql db modmon schema"
  #kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c "cd /tmp && pg_restore /tmp/backup/modmon --schema-only --clean --create --if-exists -f pgsql-modmon-schema.sql" || ERROR "Cannot retrieve modmon schema from backup"
  kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c "cd /tmp && pg_restore /tmp/backup/modmon --section=pre-data --clean --create --if-exists -f pgsql-modmon-schema.sql" || ERROR "Cannot retrieve modmon pre-data from backup"
  echo "|   |-- pgsql-modmon-schema.sql created from backup"
  #
  kubectl -n ${DR_CORE_NAMESPACE} cp pcs-postgresql-0:/tmp/pgsql-modmon-schema.sql ./pgsql-modmon-schema.sql >/dev/null || ERROR "Cannot retrieve file pcs-postgresql-0:/tmp/pgsql-modmon-schema.sql"
  #
  awk '{if(!/^--/){print};}' pgsql-modmon-schema.sql |sed '/^$/N;/^\n$/D' > ./pgsql-modmon-schema-fixed.sql || ERROR 'Cannot parce ./pgsql-modmon-schema.sql'
  #cp pgsql-modmon-schema-fixed.sql pgsql-modmon-schema-cut.sql

  echo "|   |-- Fixing modmon database tables variables types:"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_feature_stats" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_feature_stats_segment" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_feature_category_stats" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_feature_category_stats_segment" "value_count"

  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_classification_stats" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_classification_stats" "actual_count"

  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_classification_stats_segment" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_classification_stats_segment" "actual_count"

  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_regression_stats" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_regression_stats" "actual_count"

  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_regression_stats_segment" "value_count"
  fix_value "./pgsql-modmon-schema-fixed.sql" "modmon_prediction_regression_stats_segment" "actual_count"
  echo "|   |   '-- Done"

  #cp pgsql-modmon-schema-fixed.sql pgsql-modmon-schema-cut.sql
  echo "|   |-- Removing obsolete functions and aggregates:"
  #### remove FUNCTION validate_bh_tt_count_less_than
  echo "|   |   |-- FUNCTION validate_bh_tt_count_less_than"
  cp -f pgsql-modmon-schema-fixed.sql pgsql-modmon-schema-fixed2.sql
  cat pgsql-modmon-schema-fixed2.sql|awk 'BEGIN{mode=0} {if(/CREATE FUNCTION public.validate_bh_tt_count_less_than/){mode=1}; if(mode==0){print}; if(mode==1){if(/^\s*\$\$;/){mode=0};};}'> pgsql-modmon-schema-fixed.sql
  sed -i '/validate_bh_tt_count_less_than/d' pgsql-modmon-schema-fixed.sql
  rm -f pgsql-modmon-schema-fixed2.sql

  #### remove  FUNCTION validate_bh_tt_percentiles
  echo "|   |   |-- FUNCTION validate_bh_tt_percentiles"
  cp -f pgsql-modmon-schema-fixed.sql pgsql-modmon-schema-fixed2.sql
  cat pgsql-modmon-schema-fixed2.sql|awk 'BEGIN{mode=0} {if(/CREATE FUNCTION public.validate_bh_tt_percentiles/){mode=1}; if(mode==0){print}; if(mode==1){if(/^\s*\$\$;/){mode=0};};}'> pgsql-modmon-schema-fixed.sql
  sed -i '/validate_bh_tt_percentiles/d' pgsql-modmon-schema-fixed.sql
  rm -f pgsql-modmon-schema-fixed2.sql

  #### remove AGGREGATE array_cat_agg
  echo "|   |   '-- AGGREGATE array_cat_agg"
  cp -f pgsql-modmon-schema-fixed.sql pgsql-modmon-schema-fixed2.sql
  cat pgsql-modmon-schema-fixed2.sql|awk 'BEGIN{mode=0} {if(/CREATE AGGREGATE public.array_cat_agg/){mode=1}; if(mode==0){print}; if(mode==1){if(/^\);/){mode=0};};}'> pgsql-modmon-schema-fixed.sql
  sed -i '/array_cat_agg/d' pgsql-modmon-schema-fixed.sql
  rm -f pgsql-modmon-schema-fixed2.sql
  
  kubectl -n ${DR_CORE_NAMESPACE} cp ./pgsql-modmon-schema-fixed.sql pcs-postgresql-0:/tmp/pgsql-modmon-schema-fixed.sql || ERROR "cannot upload ./pgsql-modmon-schema-fixed.sql"
  echo "|   '-- PostgreSQL databae modmon schema fixed: pgsql-modmon-schema-fixed.sql"
  #### Databases list
  echo "|-- Databases list:"
  echo
  kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "SELECT datname AS Database, pg_catalog.pg_get_userbyid(datdba) AS Owner, pg_size_pretty(pg_database_size(datname)) AS Size FROM pg_database ORDER BY pg_database_size(datname) DESC;"|psql -Upostgres -hlocalhost' || ERROR "error listing PostgreSQL databases"
  # drop database
	echo -n "|-- Are you sure you want to drop modmon database to restore it? (y/N): "
  read i
  ANSWER=$(echo "${i}"|xargs|tr 'A-Z' 'a-z')
  if [ "x${ANSWER}" != "xy" ]; then
    echo "|   '-- Deletion not confirmed"
	else
		echo "|-- Dropping PgSQL database"
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "SELECT pg_terminate_backend(pg_stat_activity. pid) FROM pg_stat_activity WHERE pg_stat_activity. datname = '"'modmon'"' AND pid <> pg_backend_pid();" | psql -Upostgres -hlocalhost' >/dev/null
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "DROP DATABASE IF EXISTS modmon;" | psql -Upostgres -hlocalhost' >/dev/null
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "\l"|psql -Upostgres -hlocalhost'|grep '^ modmon ' >/dev/null && ERROR 'dropped database modmon still exists, try again...'
    echo "|-- Database modmon dropped"
    #### Databases list
    #
    echo "|-- Databases list:"
    echo
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "SELECT datname AS Database, pg_catalog.pg_get_userbyid(datdba) AS Owner, pg_size_pretty(pg_database_size(datname)) AS Size FROM pg_database ORDER BY pg_database_size(datname) DESC;"|psql -Upostgres -hlocalhost' || ERROR "error listing PostgreSQL databases"
    echo "|-- Ready to restore the modmon db data"
    echo
    echo "Press ENTER to continue or Ctrl-c to stop"
    read AAAA
    echo -n "|-- Recreating the modmon database and loading the schema ... "
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && psql --username postgres --host localhost --file /tmp/pgsql-modmon-schema-fixed.sql 2>&1 > /tmp/pgsql_create.log' || ERROR "Error creating database and loading the schema (log pcs-postgresql-0:/tmp/pgsql_create.log)"
    echo Ok
    echo "|-- Restoring PgSQL database"
    echo "|-- Logs pcs-postgresql-0:/tmp/pgsql_restore.log"
    #kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && pg_restore -Upostgres -hlocalhost -cC -j4 -d modmon /tmp/backup/modmon 2>&1| tee /tmp/pgsql_restore.log '
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && pg_restore -Upostgres -hlocalhost --section=data --section=post-data -j4 -d modmon -Fd /tmp/backup/modmon 2>&1 >> /tmp/pgsql_restore.log'
    if [ $? -eq 0 ]; then
      echo "|-- PostgreSQL restoration exist code is 0, log file pgsql_restore.log"
      kubectl -n ${DR_CORE_NAMESPACE} cp pcs-postgresql-0:/tmp/pgsql_restore.log ./pgsql_restore.log >/dev/null
    else
      kubectl -n ${DR_CORE_NAMESPACE} cp pcs-postgresql-0:/tmp/pgsql_restore.log ./pgsql_restore.log
      ERROR "PostgreSQL restoration exit code is not 0, restore failded, check log pgsql_restore.log"
    fi
    #### Databases list
    echo "|-- Databases list:"
    echo
    kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-postgresql-0 -- bash -c 'export PGPASSWORD=${POSTGRES_POSTGRES_PASSWORD} && echo "SELECT datname AS Database, pg_catalog.pg_get_userbyid(datdba) AS Owner, pg_size_pretty(pg_database_size(datname)) AS Size FROM pg_database ORDER BY pg_database_size(datname) DESC;"|psql -Upostgres -hlocalhost' || ERROR "error listing PostgreSQL databases"
    echo
    echo "|-- Completed: PgSQL modmon database restored"
  fi
}

#### #### #### #### #### #### #### ####
check_mongodb_master () {
  kubectl -n ${DR_CORE_NAMESPACE} exec -it pcs-mongo-0 -- bash -c 'echo "rs.isMaster().primary"|mongosh -u ${MONGODB_ROOT_USER} -p ${MONGODB_ROOT_PASSWORD}'|grep ^pcs-mongo-0 >/dev/null 2>&1 || ERROR "#### if pcs-mongo-0 is not master, make sure it is master before processing"
  echo "|-- MongoDB cluster status: pcs-mongo-0 is master"
}

#### #### #### #### #### #### #### ####
check_pgsql_master () {
  local PGSTATUS=$(kubectl exec -i -t -n ${DR_CORE_NAMESPACE} pcs-postgresql-0 -c postgresql -- bash -c "/opt/bitnami/scripts/postgresql-repmgr/entrypoint.sh repmgr cluster show -f /opt/bitnami/repmgr/conf/repmgr.conf --compact 2>/dev/null|grep -v 'command terminated with exit code 25'" |grep -v postgresql-repmgr|grep -v '^\s*$')
  echo "|-- PostgreSQL cluster status:"
  echo "${PGSTATUS}"|sed 's/^/| /g'
  echo "${PGSTATUS}"|grep 'pcs-postgresql-0'|grep '* running'>/dev/null 2>&1 || ERROR "#### if pcs-postgresql-0 is not master, make sure it is master before processing,
#### run the following command against the current master to push it out:
kubectl exec -i -t -n ${DR_CORE_NAMESPACE} pcs-postgresql-X -- bash -c '/opt/bitnami/postgresql/bin/pg_ctl -D /bitnami/postgresql/data -m fast stop'"
}

#### #### #### #### #### #### #### ####
recover_jobs () {
  echo "|-- Recovering jobs"
  kubectl -n ${DR_CORE_NAMESPACE} exec -it deploy/task-manager-app -- /entrypoint sbin/datarobot-manage-queue recover-jobs
  echo "|   '-- Recovering jobs"
}

#### #### #### #### #### #### #### ####
lrs_restore () {
  echo "|-- To restore lrs, please execute the following command manually:"
  echo
  echo "kubectl -n ${DR_CORE_NAMESPACE} exec deploy/mmapp-app -it -- /entrypoint tools/custom_model/restore_custom_models.py --webserver-address https://${DOMAIN} --admin-api-token <ADMIN_API_TOKEN>"
  echo
}

#### #### #### #### #### #### #### ####
#pcs-rabbitmq pcs-redis-node
reset_redis () {
  echo "|-- Re-init for redis"
  kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-redis-node --replicas=0 >/dev/null
  while kubectl -n ${DR_CORE_NAMESPACE} get po|grep pcs-redis-node- >/dev/null 2>&1; do sleep 5; done
  echo "|   |-- redis scaled down"
  kubectl -n ${DR_CORE_NAMESPACE} delete sts pcs-redis-node >/dev/null || ERROR "cannot delete sts redis"
  echo "|   |-- sts pcs-redis-node deleted"
  for i in $(kubectl -n ${DR_CORE_NAMESPACE} get pvc|grep redis-data-pcs-redis-node|awk '{print $1}'); do
    kubectl -n ${DR_CORE_NAMESPACE} delete pvc $i >/dev/null || ERROR "Cannot delete pvc $i"
    echo "|   |-- pvc $i deleted"
  done
  echo "|   '-- Re-init for redis done"
}

#### #### #### #### #### #### #### ####
reset_rabbitmq () {
  echo "|-- Re-init for RabbitMQ"
  kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-rabbitmq --replicas=0 >/dev/null
  while kubectl -n ${DR_CORE_NAMESPACE} get po|grep pcs-rabbitmq- >/dev/null 2>&1; do sleep 5; done
  echo "|   |-- RabbitMQ scaled down"
  kubectl -n ${DR_CORE_NAMESPACE} delete sts pcs-rabbitmq >/dev/null || ERROR "cannot delete sts redis"
  echo "|   |-- sts pcs-rabbitmq deleted"
  for i in $(kubectl -n ${DR_CORE_NAMESPACE} get pvc |grep data-pcs-rabbitmq |awk '{print $1}'); do
    kubectl -n ${DR_CORE_NAMESPACE} delete pvc $i >/dev/null || ERROR "Cannot delete pvc $i"
    echo "|   |-- pvc $i deleted"
  done
  echo "|   '-- Re-init for RabbitMQ done"
}

#### #### #### #### #### #### #### ####
pgsql_scale_up () {
  if [ "x1" = "x${PGSQL_REPLICAS}" ]; then
    echo "|-- Postgresql statefulset had 1 replica, no need to scale up"
  else
    kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-postgresql --replicas=${PGSQL_REPLICAS} >/dev/null || ERROR "Cannot scale Postgresql: kubectl -n ${DR_CORE_NAMESPACE} scale sts pcs-postgresql --replicas=${PGSQL_REPLICAS}"
    echo "|-- Postgresql statefulset scaled to ${PGSQL_REPLICAS}"
  fi
}

#### #### #### #### #### #### #### ####
dr_chart () {
  echo "|"
  echo "|-- Applying DataRobot helm chart"
  echo "|   |-- command:"
  echo "|   |   '-- helm upgrade --install ${DR_RELEASE} ${PRIME} -n ${DR_CORE_NAMESPACE} -f ${VALUES} --debug --timeout 20m"
  echo "|   |--  Logs can be found in datarobot-prime.log"
  echo "|   |    This can take up to 20 minutes..."
  if helm upgrade --install ${DR_RELEASE} ${PRIME} -n ${DR_CORE_NAMESPACE} -f ${VALUES} --debug --timeout 20m > datarobot-prime.log 2>&1 ; then
    echo "|   |-- DataRobot helm chart applied"
  else
    ERROR "chart application failed, the command:

    helm upgrade --install ${DR_RELEASE} ${PRIME} -n ${DR_CORE_NAMESPACE} -f ${VALUES} --debug --timeout 20m

"
  fi
  echo "|   |-- Waiting for pods to start"
  while ! kubectl -n ${DR_CORE_NAMESPACE} get po|grep 'core-nginx-.*\s*1/1\s*Running' >/dev/null; do sleep 10; done
  echo "|   '-- DataRobot helm chart applied and the system is back up"
  pgsql_scale_up
}

#### #### #### #### #### #### #### ####
are_you_ready () {
  echo "|"
  echo "| Restoring DataRobot 8 data will rewrite all existing DataRobot 11 data"
	echo -n "|-- Are you sure you are ready to proceed with data restoration? (y/N): "
  read i
  ANSWER=$(echo "${i}"|xargs|tr 'A-Z' 'a-z')
  if [ "x${ANSWER}" != "xy" ]; then
    echo "|   '-- Restoration not confirmed"
    echo "'-- The End"
    exit 1
	else
		echo "|-- Restoration confirmed"
		echo "|"
  fi
}

#### #### #### #### #### #### #### ####
upgrade_mongo () {
  echo "|"
  echo "|-- MongoDB data upgrade (it may take time) ..."
  echo "|   |-- Logs in mongo_upgrade.log"
  # old mongo upgrade
	#kubectl -n ${DR_CORE_NAMESPACE} exec deploy/mmapp-app -it -- /entrypoint datarobot-migrate-db 2>&1|tee mongo_upgrade.log || exit 1
  # new all dbs check/upgrade
  #kubectl -n ${DR_CORE_NAMESPACE} exec -it deploy/mmapp-app -- /entrypoint sbin/datarobot-drcore-mongo-migration 2>&1|tee mongo_upgrade.log || exit 1
  kubectl -n ${DR_CORE_NAMESPACE} exec -it deploy/mmapp-app -- /entrypoint sbin/datarobot-drcore-mongo-migration >mongo_upgrade.log 2>&1 || exit 1
	echo "|   '-- MongoDB post-upgrade finished (logs in mongo_upgrade.log)"
}

#### #### #### #### #### #### #### ####
  mongo_migrate_access_controls_to_policies () {
    echo "|-- MongoDB datarobot-migrate-db migrate_access_controls_to_policies ..."
    echo "    |-- Logs in mongo_migrate_access_controls_to_policies.log"
    if kubectl -n ${DR_CORE_NAMESPACE} exec -it deploy/mmapp-app -- /entrypoint sbin/datarobot-migrate-db --force_run migration_20230307094853_migrate_access_controls_to_policies >mongo_migrate_access_controls_to_policies.log 2>&1; then
      echo "|   '-- mongo datarobot-migrate-db migrate_access_controls_to_policies completed"
    else
      ERROR "kubectl -n ${DR_CORE_NAMESPACE} exec -it deploy/mmapp-app -- /entrypoint sbin/datarobot-migrate-db --force_run migration_20230307094853_migrate_access_controls_to_policies"
    fi
  }

#### #### #### #### #### #### #### ####
mongodb_redis_id_fix () {
  echo "|"
  echo "|-- MongoDB redis id generation fix (log mongodb_redis_id_fix)..."
  echo "    |-- Logs in mongodb_redis_id_fix.log"
  kubectl -n ${DR_CORE_NAMESPACE} exec deploy/mmapp-app -it -- /entrypoint ./bin/datarobot-default-python -c "from common.services.queues.queue_service import QueueService;from common.wrappers.database import new_persistent;from common.engine import progress; [QueueService(p['_id'], progress.factory(), p['uid']).restore_tempstore() for p in new_persistent().conn['project'].find({}, {'_id': 1, 'uid': 1})]" > mongodb_redis_id_fix.log 2>&1 || ERROR "MongoDB redis id generation fix failed"
  echo "|   '-- MongoDB redis id generation fix completed"
  echo "|"
}

#### #### #### #### #### #### #### ####
full_check () {
  backup_check
  version_check
  get_config
  check_config
  check_mongodb_master
  check_pgsql_master
}

#### #### #### #### #### #### #### ####
mongo_post_migration () {
  upgrade_mongo
  mongo_migrate_access_controls_to_policies
  mongodb_redis_id_fix
}
#### #### #### #### #### #### #### ####
full_restore () {
  are_you_ready
  scale_down
  disable_cron_job
  core_credentials
  restore_mongo_local
  restore_pgsql_local
  reset_redis
  reset_rabbitmq
  dr_chart
  disable_cron_job
  mongo_post_migration
  enable_cron_job
  recover_jobs
  lrs_restore
}

#### #### #### #### #### #### #### ####
helpme () {
  echo "
  DataRobot 8 backup restoration into DataRobot 11 cluster.
    Usage: $0 <ACTION>

    Actions in order to perform data restoration:
      check             - verify backup and system
      scale-down        - scale DataRobot app down
      disable-cron      - disable cron mongo-migration-job
      core-credentials  - restore core-credentials secret from DataRobot 8 backup
      restore-mongo     - restore mongodb from DataRobot 8 backup
      restore-pgsql     - restore PostgreSQL from DataRobot 8 backup
      reset-redis       - reset (delete) redis including pvcs
      reset-rabbitmq    - reset (delete) RabbitMQ including pvcs
      chart-apply       - apply DataRobot 11 helm chart
      disable-cron      - disable cron mongo-migration-job (again!)
      upgrade-dbs       - dbs check and MongoDB post migrations
      enable-cron       - enable cron mongo-migration-job
      recover-jobs      - DataRobot 11 recover jobs task
      lrs-restore       - print command to restore lrs

    Or you can go through full cysle utilizing this single command:  
      full-restore       - perform the full restoration in one step
      
"
}

#### #### #### #### #### #### #### ####
#### MAIN PROGRAM
#### #### #### #### #### #### #### ####

RESTORE_DIR=$(readlink -f ${BACKUPS_DIR} 2>/dev/null)
SECRETS_RESTORE_DIR="${RESTORE_DIR}/secrets"
MONGO_RESTORE_DIR="${RESTORE_DIR}/mongo"
PGSQL_RESTORE_DIR="${RESTORE_DIR}/pgsql"
KEY1_FILE="${RESTORE_DIR}/secrets/ASYMMETRIC_KEY_PAIR_MONGO_ENCRYPTION_KEY.txt"
KEY2_FILE="${RESTORE_DIR}/secrets/DRSECURE_MONGO_ENCRYPTION_KEY.txt"
MONGO_RESTORE_TAR=$(ls -1 ${MONGO_RESTORE_DIR}/datarobot-mongo50-backup-*.tar 2>/dev/null|tail -1)
PGSQL_RESTORE_TAR=$(ls -1 ${PGSQL_RESTORE_DIR}/pgsql-modmon-*.tar 2>/dev/null|tail -1)
helm list -A >/dev/null 2>&1 || ERROR "Failed command: helm list -A"
DR_CURRENT_VERSION=$(helm list -A|grep datarobot-|grep -v datarobot-pcs-|awk '{print $NF}'|sed 's/\-.*//g') || ERROR "Failed command: helm list -A"
DR_CORE_NAMESPACE=$(helm list -A|grep datarobot-|head -1|awk '{print $2}')
DR_RELEASE=$(helm list -A|grep datarobot-|head -1|awk '{print $1}')
kubectl -n ${DR_CORE_NAMESPACE} get pods >/dev/null 2>&1 || ERROR "kubectl cannot retrieve k8s data"
VALUES="values.yaml"
ASYMMETRIC_KEY_PAIR_MONGO_ENCRYPTION_KEY=$(cat ${KEY1_FILE} 2>/dev/null|tr -d '\r')
DRSECURE_MONGO_ENCRYPTION_KEY=$(cat ${KEY2_FILE} 2>/dev/null|tr -d '\r')
PRIME="datarobot-prime-${DR_CURRENT_VERSION}.tgz"
DOMAIN="DATAROBOT-WEBUI-URL"
PGSQL_REPLICAS=$(kubectl -n ${DR_CORE_NAMESPACE} get sts pcs-postgresql -o jsonpath='{.spec.replicas}')
MONGO_REPLICAS=$(kubectl -n ${DR_CORE_NAMESPACE} get sts pcs-mongo -o jsonpath='{.spec.replicas}')
for i in PGSQL_REPLICAS MONGO_REPLICAS; do
  [ -z "${!i}" ] && ERROR "Cannot get $i from the cluster"
  [ "${!i}" = "0" ] && ERROR "$i = 0"
done

#full_check
#
[ -z "$1" ] && helpme

while [ -n "$1" ]; do
  echo ".-- Step: $1"
  case $1 in
  full-restore)
    full_check;
    full_restore
    ;;
  check) full_check ;;
  scale-down) scale_down ;;
  disable-cron) disable_cron_job ;;
  core-credentials) core_credentials ;;
  restore-mongo) check_mongodb_master; restore_mongo_local ;;
  restore-pgsql) check_pgsql_master; restore_pgsql_local ;;
  reset-redis) reset_redis ;;
  reset-rabbitmq) reset_rabbitmq ;;
  chart-apply) dr_chart ;;
  pgsql-scale-up) pgsql_scale_up ;;
  mongo-migration|upgrade-dbs) mongo_post_migration ;;
  enable-cron) enable_cron_job ;;
  recover-jobs) recover_jobs ;;
  lrs-restore) lrs_restore ;;
  *) helpme
    ;;
  esac
  echo "'-- Step: $1"
  shift
done
exit 0
#### #### #### #### #### #### #### ####
#### END
#### #### #### #### #### #### #### ####
